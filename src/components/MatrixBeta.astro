---
type Props = {
    delay: number;
};
const { delay } = Astro.props;
---

<style>
    body,
    html {
        margin: 0;
        padding: 0;
        height: 100%; /* You may adjust or remove this if it conflicts with other content */
        background: var(--background);
    }

    .matrix-effect canvas {
        transition:
            background-color 0.5s,
            opacity 0.5s;
    }

    .matrix-effect {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 2;
        pointer-events: none;
        overflow: hidden; /* Ensure that only the effect container is non-scrollable */
    }
</style>

<div id="matrixEffect" class="matrix-effect" fade-out={delay}></div>
<script>
    const matrixEffectElement = document.getElementById("matrixEffect");
    const timeout = matrixEffectElement
        ? parseInt(matrixEffectElement.getAttribute("fade-out") || "0", 10)
        : 0;

    const matrixChars = [
        "ｦ",
        "ｧ",
        "ｨ",
        "ｩ",
        "ｪ",
        "ｫ",
        "ｬ",
        "ｭ",
        "ｮ",
        "ｯ",
        "ｰ",
        "ｱ",
        "ｲ",
        "ｳ",
        "ｴ",
        "ｵ",
        "ｶ",
        "ｷ",
        "ｸ",
        "ｹ",
        "ｺ",
        "ｻ",
        "ｼ",
        "ｽ",
        "ｾ",
        "ｿ",
        "ﾀ",
        "ﾁ",
        "ﾂ",
        "ﾃ",
        "ﾄ",
        "ﾅ",
        "ﾆ",
        "ﾇ",
        "ﾈ",
        "ﾉ",
        "ﾊ",
        "ﾋ",
        "ﾌ",
        "ﾍ",
        "ﾎ",
        "ﾏ",
        "ﾐ",
        "ﾑ",
        "ﾒ",
        "ﾓ",
        "ﾔ",
        "ﾕ",
        "ﾖ",
        "ﾗ",
        "ﾘ",
        "ﾙ",
        "ﾚ",
        "ﾛ",
        "ﾜ",
        "ﾝ",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "!",
        "@",
        "#",
        "$",
        "%",
        "&",
        "*",
        "(",
        ")",
        "+",
        "-",
        "/",
        ":",
        ";",
        "<",
        ">",
    ];

    document.addEventListener("DOMContentLoaded", function () {
        const matrixEffect = document.getElementById("matrixEffect");
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        if (!ctx) {
            console.error("Failed to get 2D context");
            return;
        }
        if (matrixEffect) {
            matrixEffect.appendChild(canvas);
        }
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const fontSize = 16;
        const columns = Math.floor(canvas.width / fontSize);
        const drops = Array(columns)
            .fill(0)
            .map(() => Math.floor((Math.random() * -canvas.height) / fontSize));

        function drawMatrix() {
            if (!ctx) {
                console.error("2D context is null");
                return;
            }
            ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < drops.length; i++) {
                const char =
                    matrixChars[Math.floor(Math.random() * matrixChars.length)];
                const isBottomMost =
                    drops[i] * fontSize > canvas.height || Math.random() > 0.95;
                ctx.font = isBottomMost
                    ? `bold ${fontSize}px monospace`
                    : `${fontSize}px monospace`;
                ctx.fillStyle = isBottomMost ? "#FFF" : "#0f0";
                ctx.fillText(char, i * fontSize, drops[i] * fontSize);
                drops[i] =
                    drops[i] * fontSize > canvas.height || isBottomMost
                        ? 0
                        : drops[i] + 1;
            }
        }

        function addErraticBlinkEffect() {
            setInterval(
                () => {
                    const shouldBlinkWhite = Math.random() > 0.5;
                    canvas.style.backgroundColor = shouldBlinkWhite
                        ? "white"
                        : "black";
                    canvas.style.opacity = shouldBlinkWhite
                        ? "1"
                        : Math.random().toString();
                    setTimeout(
                        () => {
                            canvas.style.backgroundColor = "black";
                            canvas.style.opacity = "1";
                        },
                        Math.random() * 100 + 50,
                    );
                },
                Math.random() * 500 + 100,
            );
        }

        setInterval(drawMatrix, 40);
        addErraticBlinkEffect();

        function rapidBlinkBeforeEnd() {
            const rapidBlinkInterval = setInterval(() => {
                if (matrixEffectElement) {
                    matrixEffectElement.style.opacity =
                        matrixEffectElement.style.opacity === "1" ? "0" : "1";
                    matrixEffectElement.style.backgroundColor =
                        matrixEffectElement.style.opacity === "0"
                            ? "black"
                            : "transparent";
                }
            }, 30);

            setTimeout(() => {
                clearInterval(rapidBlinkInterval);
                if (matrixEffectElement) {
                    matrixEffectElement.style.opacity = "1";
                }
                if (matrixEffectElement) {
                    matrixEffectElement.style.backgroundColor = "transparent";
                }
                if (matrixEffectElement) {
                    matrixEffectElement.style.display = "none";
                }
            }, timeout / 10);
        }

        setTimeout(() => rapidBlinkBeforeEnd(), timeout - timeout / 10);
        setTimeout(() => {
            if (matrixEffectElement) {
                matrixEffectElement.style.display = "none";
            }
        }, timeout);
    });
</script>
