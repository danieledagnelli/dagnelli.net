---
type Props = {
    delay: number;
};
const { delay } = Astro.props;
---

<style>
    body,
    html {
        margin: 0;
        padding: 0;
        height: 100%; /* You may adjust or remove this if it conflicts with other content */
        background: var(--background);
    }

    .matrix-effect canvas {
        transition:
            background-color 0.5s,
            opacity 0.5s;
    }

    .matrix-effect {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 2;
        pointer-events: none;
        overflow: hidden; /* Ensure that only the effect container is non-scrollable */
    }
</style>

<div id="matrixEffect" class="matrix-effect" fade-out={delay}></div>

<script>
    const matrixEffectElement = document.getElementById("matrixEffect");
    const timeout = matrixEffectElement
        ? parseInt(matrixEffectElement.getAttribute("fade-out") || "0", 10)
        : 0;

    // A subset of half-width Katakana, Western letters, numerals, and symbols
    const matrixChars = [
        "ｦ",
        "ｧ",
        "ｨ",
        "ｩ",
        "ｪ",
        "ｫ",
        "ｬ",
        "ｭ",
        "ｮ",
        "ｯ",
        "ｰ",
        "ｱ",
        "ｲ",
        "ｳ",
        "ｴ",
        "ｵ",
        "ｶ",
        "ｷ",
        "ｸ",
        "ｹ",
        "ｺ",
        "ｻ",
        "ｼ",
        "ｽ",
        "ｾ",
        "ｿ",
        "ﾀ",
        "ﾁ",
        "ﾂ",
        "ﾃ",
        "ﾄ",
        "ﾅ",
        "ﾆ",
        "ﾇ",
        "ﾈ",
        "ﾉ",
        "ﾊ",
        "ﾋ",
        "ﾌ",
        "ﾍ",
        "ﾎ",
        "ﾏ",
        "ﾐ",
        "ﾑ",
        "ﾒ",
        "ﾓ",
        "ﾔ",
        "ﾕ",
        "ﾖ",
        "ﾗ",
        "ﾘ",
        "ﾙ",
        "ﾚ",
        "ﾛ",
        "ﾜ",
        "ﾝ",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "!",
        "@",
        "#",
        "$",
        "%",
        "&",
        "*",
        "(",
        ")",
        "+",
        "-",
        "/",
        ":",
        ";",
        "<",
        ">",
    ];

    document.addEventListener("DOMContentLoaded", function () {
        const matrixEffect = document.getElementById("matrixEffect");
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        if (!ctx) {
            console.error("Failed to get 2D context");
            return;
        }
        if (matrixEffect) {
            if (matrixEffect) {
                if (matrixEffect) {
                    if (matrixEffect) {
                        matrixEffect.appendChild(canvas);
                    } else {
                        console.error("Failed to find matrixEffect element");
                    }
                } else {
                    console.error("Failed to find matrixEffect element");
                }
            } else {
                console.error("Failed to find matrixEffect element");
            }
        } else {
            console.error("Failed to find matrixEffect element");
        }
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const fontSize = 16;
        const columns = Math.floor(canvas.width / fontSize);

        // Initialize each column to start randomly within bounds
        const drops = Array(columns)
            .fill(0)
            .map(() => Math.floor((Math.random() * -canvas.height) / fontSize));

        const distortions: { y: number; thickness: number; opacity: number }[] =
            []; // Array to track active horizontal distortion lines

        function drawMatrix() {
            if (!ctx) {
                return;
            }
            // Slightly dark background to fade old characters
            if (ctx) {
                if (ctx) {
                    if (ctx) {
                        ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
                    }
                }
            }
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Iterate through each column
            for (let i = 0; i < drops.length; i++) {
                const char =
                    matrixChars[Math.floor(Math.random() * matrixChars.length)];

                // Check if the character is the bottom-most in its drop
                const isBottomMost =
                    drops[i] * fontSize > canvas.height ||
                    (Math.random() > 0.95 &&
                        drops[i] * fontSize < canvas.height);

                if (isBottomMost) {
                    // Apply bold and white styling for bottom-most character
                    ctx.font = `bold ${fontSize}px monospace`;
                    ctx.fillStyle = "#FFF"; // White color
                } else {
                    // Regular styling for other characters
                    ctx.font = `${fontSize}px monospace`;
                    ctx.fillStyle = "#0f0"; // Regular green color
                }

                ctx.fillText(char, i * fontSize, drops[i] * fontSize);

                // Reset the drop or continue moving it down
                if (drops[i] * fontSize > canvas.height || isBottomMost) {
                    drops[i] = 0; // Reset the drop to start from the top
                } else {
                    drops[i]++;
                }
            }
        }

        // Function to add flashing effect
        function flashBottomCharacter(isBottomMost: any) {
            const flashInterval = setInterval(() => {
                if (isBottomMost && ctx) {
                    // Toggle opacity to create a flashing effect
                    ctx.globalAlpha = ctx.globalAlpha === 1 ? 0 : 1;
                }
            }, 200); // Flashing interval

            // Optionally, clear the interval based on certain conditions or after a set duration
            setTimeout(() => {
                clearInterval(flashInterval);
            }, 10000); // Stop flashing after 10 seconds, adjust as needed
        }

        setInterval(drawMatrix, 40);

        function addDistortionLine() {
            const y = Math.random() * canvas.height; // Random vertical position
            const thickness = Math.random() * 10 + 5; // Random thickness (5px-15px)
            distortions.push({ y, thickness, opacity: 1 });
        }

        function addErraticBlinkEffect() {
            setInterval(
                () => {
                    const shouldBlinkWhite = Math.random() > 0.5;

                    if (shouldBlinkWhite) {
                        canvas.style.backgroundColor = "white";
                        canvas.style.opacity = "1"; // Fully visible white
                    } else {
                        canvas.style.backgroundColor = "black";
                        const randomOpacity = Math.random(); // Random dim effect
                        // const randomOpacity = 0; // Random dim effect

                        canvas.style.opacity = randomOpacity.toString();
                    }

                    // Reset to normal state
                    setTimeout(
                        () => {
                            canvas.style.backgroundColor = "black";
                            canvas.style.opacity = "1";
                        },
                        Math.random() * 100 + 50,
                    ); // Duration between 50ms to 150ms
                },
                Math.random() * 500 + 100,
            ); // Frequency between 100ms to 600ms
        }

        setInterval(drawMatrix, 40);
        setInterval(addDistortionLine, Math.random() * 1000 + 500); // New distortion line every 500ms-1500ms
        addErraticBlinkEffect();

        function rapidBlinkBeforeEnd() {
            const rapidBlinkInterval = setInterval(() => {
                if (matrixEffectElement) {
                    // Toggle the opacity
                    matrixEffectElement.style.opacity =
                        matrixEffectElement.style.opacity === "1" ? "0" : "1";

                    // Set the background color based on the opacity
                    matrixEffectElement.style.backgroundColor =
                        matrixEffectElement.style.opacity === "0"
                            ? "black"
                            : "transparent";
                }
            }, 30); // Very fast blinking at 30 milliseconds

            // Stop the rapid blinking and clear the matrix effect after a brief period
            setTimeout(() => {
                clearInterval(rapidBlinkInterval);
                if (matrixEffectElement) {
                    matrixEffectElement.style.opacity = "1"; // Ensure it's visible before hiding
                    matrixEffectElement.style.backgroundColor = "transparent"; // Reset background to initial state
                }
                if (matrixEffectElement) {
                    matrixEffectElement.style.display = "none";
                }
            }, timeout / 10); // Adjust time as needed (here, 1 second of rapid blinking)
        }

        // Start the rapid blinking shortly before the main timeout
        setTimeout(
            () => {
                rapidBlinkBeforeEnd();
            },
            timeout - timeout / 10,
        ); // Start 1 second before the main timeout

        // Set the main timeout to hide the matrix effect
        setTimeout(function () {
            if (matrixEffectElement) {
                matrixEffectElement.style.display = "none";
            }
        }, timeout);
    });
</script>
