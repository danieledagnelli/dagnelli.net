---
type Props = {
    delay: number;
};
const { delay } = Astro.props;
---

<style>
    body,
    html {
        margin: 0;
        padding: 0;
        height: 100%; /* Full height */
        background: var(--background);
    }

    .matrix-effect {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 2;
        pointer-events: none;
        overflow: hidden; /* Prevents scrolling within the effect container */
    }
</style>

<div id="matrixEffect" class="matrix-effect" fade-out={delay}></div>
<script>
    (function () {
        "use strict";

        /**
         * Safely read the 'fade-out' attribute from the #matrixEffect element
         * @returns {number} Parsed timeout value (0 if invalid or missing)
         */
        function getTimeoutValue(element: HTMLElement) {
            if (!element) {
                console.warn(
                    "Matrix effect element not found to read 'fade-out' attribute.",
                );
                return 0;
            }

            const fadeOutAttr = element.getAttribute("fade-out");
            if (!fadeOutAttr) {
                console.warn(
                    "'fade-out' attribute not found on #matrixEffect element.",
                );
                return 0;
            }

            const parsed = parseInt(fadeOutAttr, 10);
            if (isNaN(parsed)) {
                console.warn(
                    `Invalid 'fade-out' attribute value: ${fadeOutAttr}`,
                );
                return 0;
            }

            return parsed;
        }

        /**
         * Creates a canvas element inside the given parent and returns the context.
         * @returns {{ canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D | null} | null}
         */
        function createCanvasAndContext(parent: HTMLElement) {
            if (!parent) {
                console.warn(
                    "Parent element is null or undefined. Cannot create canvas.",
                );
                return null;
            }

            const canvas = document.createElement("canvas");
            parent.appendChild(canvas);
            const ctx = canvas.getContext("2d");

            if (!ctx) {
                console.warn(
                    "Unable to get 2D context from the created canvas.",
                );
            }

            return { canvas, ctx };
        }

        /**
         * Initializes the Matrix effect (creates canvas, sets up intervals).
         */
        function initMatrixEffect() {
            // Get the container element
            const matrixEffectElement = document.getElementById("matrixEffect");
            if (!matrixEffectElement) {
                console.warn(
                    "#matrixEffect element not found in the DOM. Skipping Matrix effect initialization.",
                );
                return;
            }

            const timeout = getTimeoutValue(matrixEffectElement);
            const result = createCanvasAndContext(matrixEffectElement);
            if (!result || !result.canvas || !result.ctx) {
                // If canvas or context is invalid, exit early
                return;
            }

            const { canvas, ctx } = result;

            // Set initial canvas dimensions
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Matrix columns and drops
            const fontSize = 16;
            const columns = Math.floor(canvas.width / fontSize);
            const drops = new Array(columns)
                .fill(0)
                .map(() =>
                    Math.floor((Math.random() * -canvas.height) / fontSize),
                );

            // Define the characters used in the Matrix animation
            const matrixChars =
                "ｦｧｨｩｪｫｬｭｮｯｰｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%&*()+-/<>:;".split(
                    "",
                );

            /**
             * Draws the falling characters.
             */
            function drawMatrix() {
                if (!ctx) return; // Extra safety check if ctx was lost somehow

                // Paint a semi-transparent black rectangle over the entire canvas
                ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Set the style for the falling characters
                ctx.fillStyle = "#0F0";
                ctx.font = `${fontSize}px monospace`;

                // Draw each character in its respective column
                for (let i = 0; i < columns; i++) {
                    const text =
                        matrixChars[
                            Math.floor(Math.random() * matrixChars.length)
                        ];
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);

                    // Reset drop to the top randomly after it exits the canvas
                    if (
                        drops[i] * fontSize > canvas.height &&
                        Math.random() > 0.975
                    ) {
                        drops[i] = 0;
                    } else {
                        drops[i]++;
                    }
                }
            }

            /**
             * Adds a random horizontal "distortion" line.
             */
            function addDistortionLine() {
                if (!ctx) return; // Extra safety check

                ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                const yPosition = Math.floor(Math.random() * canvas.height);
                const lineThickness = Math.random() * 10 + 1;
                ctx.fillRect(0, yPosition, canvas.width, lineThickness);
            }

            // Start the main animation loops (check if setInterval is available)
            if (typeof setInterval === "function") {
                setInterval(drawMatrix, 50); // Matrix effect
                setInterval(addDistortionLine, 200); // Distortion lines
            } else {
                console.warn(
                    "setInterval is not available. Animations cannot be started.",
                );
            }

            // Handle the "blink" and fade-out effect at the end
            handleFadeOut(matrixEffectElement, timeout || 0, addDistortionLine);
        }

        /**
         * Handles the "blink" and fade-out effect at the end.
         * @param {HTMLElement} element
         * @param {number} timeout
         */
        function handleFadeOut(
            element: HTMLElement,
            timeout: number | undefined,
            addLinesFn: () => void,
        ) {
            if (!element || (timeout !== undefined && timeout <= 0)) {
                return;
            }

            // Blink effect at 90% of the timeout
            setTimeout(
                () => {
                    const blinkInterval = setInterval(() => {
                        element.style.opacity =
                            element.style.opacity === "1" ? "0.1" : "1";
                    }, 30);

                    const extraLinesInterval = setInterval(() => {
                        // Draw multiple thin lines
                        for (let i = 0; i < 5; i++) {
                            addLinesFn(); // <-- call the passed-in function
                        }
                    }, 40);

                    setTimeout(
                        () => {
                            clearInterval(blinkInterval);
                            clearInterval(extraLinesInterval);
                            element.style.opacity = "1";
                            element.style.display = "none";
                        },
                        (timeout || 0) / 10,
                    );
                },
                (timeout || 0) - (timeout || 0) / 10,
            );

            // Final hide
            setTimeout(() => {
                element.style.display = "none";
            }, timeout);
        }

        /**
         * Main entry point when DOM is loaded.
         */
        function onDomContentLoaded() {
            // Check for 'document' just in case
            if (typeof document === "undefined") {
                console.warn(
                    "document is not available, cannot initialize Matrix effect.",
                );
                return;
            }
            initMatrixEffect();
        }

        // Initialize when DOM content is fully loaded
        if (typeof document !== "undefined") {
            document.addEventListener("DOMContentLoaded", onDomContentLoaded);
        } else {
            console.warn(
                "document is not defined. Skipping DOMContentLoaded listener.",
            );
        }
    })();
</script>
