<style>
    body,
    html {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: black;
    }
    .matrix-effect {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1;
        pointer-events: none;
    }
</style>

<div id="matrixEffect" class="matrix-effect"></div>
<script>
    // A subset of half-width Katakana, Western letters, numerals, and symbols
    const matrixChars = [
        "ｦ",
        "ｧ",
        "ｨ",
        "ｩ",
        "ｪ",
        "ｫ",
        "ｬ",
        "ｭ",
        "ｮ",
        "ｯ",
        "ｰ",
        "ｱ",
        "ｲ",
        "ｳ",
        "ｴ",
        "ｵ",
        "ｶ",
        "ｷ",
        "ｸ",
        "ｹ",
        "ｺ",
        "ｻ",
        "ｼ",
        "ｽ",
        "ｾ",
        "ｿ",
        "ﾀ",
        "ﾁ",
        "ﾂ",
        "ﾃ",
        "ﾄ",
        "ﾅ",
        "ﾆ",
        "ﾇ",
        "ﾈ",
        "ﾉ",
        "ﾊ",
        "ﾋ",
        "ﾌ",
        "ﾍ",
        "ﾎ",
        "ﾏ",
        "ﾐ",
        "ﾑ",
        "ﾒ",
        "ﾓ",
        "ﾔ",
        "ﾕ",
        "ﾖ",
        "ﾗ",
        "ﾘ",
        "ﾙ",
        "ﾚ",
        "ﾛ",
        "ﾜ",
        "ﾝ",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "!",
        "@",
        "#",
        "$",
        "%",
        "&",
        "*",
        "(",
        ")",
        "+",
        "-",
        "/",
        ":",
        ";",
        "<",
        ">",
    ];

    document.addEventListener("DOMContentLoaded", function () {
        // Create canvas and context
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        if (!ctx) {
            console.error("Failed to get 2D context");
            return;
        }

        const matrixEffect = document.getElementById("matrixEffect");
        if (matrixEffect) {
            matrixEffect.appendChild(canvas);
        }

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const fontSize = 16;
        const columns = Math.floor(canvas.width / fontSize);

        // Initialize each column to start randomly within bounds
        const drops = Array(columns)
            .fill(0)
            .map(() => Math.floor((Math.random() * -canvas.height) / fontSize));

        const distortions: { y: number; thickness: number; opacity: number; }[] = []; // Array to track active horizontal distortion lines

        function drawMatrix() {
            if (!ctx) {
                return;
            }
            // Slightly dark background to fade old characters
            ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "#0f0";
            ctx.font = `${fontSize}px monospace`;

            for (let i = 0; i < drops.length; i++) {
                const char =
                    matrixChars[Math.floor(Math.random() * matrixChars.length)];

                // Randomly decide if this particular character should be mirrored
                const shouldMirror = Math.random() < 0.15; // ~15% chance to mirror

                if (shouldMirror) {
                    ctx.save();
                    ctx.translate(
                        (i + 0.5) * fontSize,
                        (drops[i] + 0.5) * fontSize
                    );
                    ctx.scale(-1, 1);
                    ctx.fillText(char, -0.5 * fontSize, 0.5 * fontSize);
                    ctx.restore();
                } else {
                    ctx.fillText(char, i * fontSize, drops[i] * fontSize);
                }

                // Move drop downward; occasionally reset to the top
                if (
                    drops[i] * fontSize > canvas.height &&
                    Math.random() > 0.975
                ) {
                    drops[i] = Math.floor(
                        (Math.random() * -canvas.height) / fontSize
                    );
                }
                drops[i]++;
            }

            // Draw horizontal distortion lines
            distortions.forEach((distortion, index) => {
                ctx.fillStyle = `rgba(0, 0, 0, ${distortion.opacity})`;
                ctx.fillRect(
                    0,
                    distortion.y,
                    canvas.width,
                    distortion.thickness
                );

                // Fade out distortion lines over time
                distortion.opacity -= 0.02;
                if (distortion.opacity <= 0) {
                    distortions.splice(index, 1);
                }
            });
        }

        function addDistortionLine() {
            const y = Math.random() * canvas.height; // Random vertical position
            const thickness = Math.random() * 10 + 5; // Random thickness (5px-15px)
            distortions.push({ y, thickness, opacity: 1 });
        }

        function addErraticBlinkEffect() {
            setInterval(
                () => {
                    const shouldBlinkWhite = Math.random() > 0.5;

                    if (shouldBlinkWhite) {
                        canvas.style.backgroundColor = "white";
                        canvas.style.opacity = "1"; // Fully visible white
                    } else {
                        canvas.style.backgroundColor = "black";
                        const randomOpacity = Math.random(); // Random dim effect
                        // const randomOpacity = 0; // Random dim effect

                        canvas.style.opacity = randomOpacity.toString();
                    }

                    // Reset to normal state
                    setTimeout(
                        () => {
                            canvas.style.backgroundColor = "black";
                            canvas.style.opacity = "1";
                        },
                        Math.random() * 100 + 50
                    ); // Duration between 50ms to 150ms
                },
                Math.random() * 500 + 100
            ); // Frequency between 100ms to 600ms
        }

        setInterval(drawMatrix, 40);
        setInterval(addDistortionLine, Math.random() * 1000 + 500); // New distortion line every 500ms-1500ms
        addErraticBlinkEffect();
    });
</script>
